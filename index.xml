<?xml-stylesheet href="/rss.xsl" type="text/xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>KRAPSHSA'S BLOG</title><link>https://krapshsa.github.io/</link><description>Recent content on KRAPSHSA'S BLOG</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>© 2007 - 2022 krapshsa</copyright><lastBuildDate>Mon, 15 Aug 2022 19:26:00 +0800</lastBuildDate><atom:link href="https://krapshsa.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>iOS 瀏覽器無法瀏覽高 DPI 的 pdf</title><link>https://krapshsa.github.io/posts/ios-dpi-pdf-16af8336-45e8-4ad0-8764-5a0eab1ec309/</link><pubDate>Mon, 15 Aug 2022 19:26:00 +0800</pubDate><guid>https://krapshsa.github.io/posts/ios-dpi-pdf-16af8336-45e8-4ad0-8764-5a0eab1ec309/</guid><description>KRAPSHSA'S BLOG https://krapshsa.github.io/posts/ios-dpi-pdf-16af8336-45e8-4ad0-8764-5a0eab1ec309/ -&lt;h2 id="起因">起因&lt;/h2>
&lt;p>NextCloud 有一個功能 (PDF Viewer)，&lt;/p>
&lt;p>可以讓我在手機瀏覽器上直接瀏覽 PDF。&lt;/p>
&lt;p>但是今天有一個用掃描器掃上來的 PDF 卻無法正常在手機端瀏覽&lt;/p>
&lt;br>
&lt;h2 id="症狀">症狀&lt;/h2>
&lt;p>瀏覽 pdf 的時候會一片空白，並且產生錯誤訊息&lt;/p>
&lt;pre tabindex="0">&lt;code>Canvas area exceeds the maximum limit (width * height &amp;gt; 16777216).
&lt;/code>&lt;/pre>&lt;br>
&lt;p>經查詢原來是 iOS 的 &lt;code>canvas&lt;/code> element 有大小限制：&lt;/p>
&lt;p>&lt;a href="https://pqina.nl/blog/canvas-area-exceeds-the-maximum-limit/">Canvas Area Exceeds The Maximum Limit&lt;/a>&lt;/p>
&lt;br>
&lt;p>跟 PDF.js 無關，所以這條 issue 至今也是無解：&lt;/p>
&lt;br>
&lt;h2 id="解決方法">解決方法&lt;/h2>
&lt;p>搬運 &lt;code>askubuntu&lt;/code> 的解法，先在 Server Side 用 ghost script 把 DPI 改小就好了：&lt;/p>
&lt;pre tabindex="0">&lt;code>gs -sDEVICE=pdfwrite \
-dCompatibilityLevel=1.4 \
-dPDFSETTINGS=/ebook \
-dNOPAUSE \
-dQUIET \
-dBATCH \
-sOutputFile=output.pdf input.pdf
&lt;/code>&lt;/pre>&lt;br>
&lt;ul>
&lt;li>
&lt;p>&lt;code>-dCompatibilityLevel&lt;/code> (不知道有什麼用)&lt;/p>
&lt;p>&lt;a href="https://acrobatusers.com/tutorials/understanding-pdf-compatibility-levels/">Understanding PDF compatibility levels in Acrobat 9&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>-dPDFSETTINGS&lt;/code> 用來調整 DPI&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>-dNOPAUSE&lt;/code> 停用每頁結束時的提示和暫停&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>-dQUIET&lt;/code> 安靜執行，儘量不輸出日誌&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>-dBATCH&lt;/code> 執行到最後一頁退出&lt;/p>
&lt;/li>
&lt;/ul>
&lt;br>
&lt;h2 id="參考資料">參考資料&lt;/h2>
&lt;p>&lt;a href="https://apps.nextcloud.com/apps/files_pdfviewer">PDF viewer&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://pqina.nl/blog/canvas-area-exceeds-the-maximum-limit/">Canvas Area Exceeds The Maximum Limit&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://askubuntu.com/questions/113544/how-can-i-reduce-the-file-size-of-a-scanned-pdf-file">How can I reduce the file size of a scanned PDF file?&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.ghostscript.com/doc/current/VectorDevices.htm#COMMON">High Level Output Devices&lt;/a>&lt;/p>
- https://krapshsa.github.io/posts/ios-dpi-pdf-16af8336-45e8-4ad0-8764-5a0eab1ec309/ - © 2007 - 2022 krapshsa</description></item><item><title>簡易 C Mock — wrapper function</title><link>https://krapshsa.github.io/posts/c-mock-wrapper-function-87728a4c-9871-48d0-9b84-24dc3483bce4/</link><pubDate>Sat, 06 Aug 2022 11:12:00 +0800</pubDate><guid>https://krapshsa.github.io/posts/c-mock-wrapper-function-87728a4c-9871-48d0-9b84-24dc3483bce4/</guid><description>KRAPSHSA'S BLOG https://krapshsa.github.io/posts/c-mock-wrapper-function-87728a4c-9871-48d0-9b84-24dc3483bce4/ -&lt;h2 id="起因">起因&lt;/h2>
&lt;p>幫一個舊的 Lib 寫測試的時候會去讀 config，&lt;/p>
&lt;p>但是這個路徑在我的 CI 環境並不存在，&lt;/p>
&lt;p>通常我寫 php 的時候，針對這種外部相依就用 function 包起來再 Mock 掉，&lt;/p>
&lt;p>但是 C 我已經忘得差不多了，想找一個簡單可以做到類似效果的方法。&lt;/p>
&lt;br>
&lt;h2 id="目前解法">目前解法&lt;/h2>
&lt;p>不囉唆，先上 code&lt;/p>
&lt;p>&lt;a href="https://github.com/krapshsa/c-native-mock">GitHub - krapshsa/c-native-mock&lt;/a>&lt;/p>
&lt;p>這個簡單的 Case 是這樣：&lt;/p>
&lt;ol>
&lt;li>&lt;code>main()&lt;/code> 呼叫 &lt;code>foo()&lt;/code> ， &lt;code>foo()&lt;/code> 呼叫 &lt;code>config_load()&lt;/code>&lt;br>
&lt;img src="c-mock-9adcb40d-b2d3-4874-9829-170784e9f812.png" alt="">&lt;/li>
&lt;li>我想要不改變 &lt;code>foo.c&lt;/code> ，讓測試 (&lt;code>main.c&lt;/code> ) 可以不去真的用到 &lt;code>config_load()&lt;/code>&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>其實這就相當於寫測試：&lt;/p>
&lt;p>&lt;code>main()&lt;/code> 是 Test，而 &lt;code>foo.c&lt;/code> 的 &lt;code>foo()&lt;/code> 是我的 SUT (System Under Test)。&lt;/p>
&lt;br>
&lt;p>手法就是 Wrap，根據 &lt;code>ld&lt;/code> 的 Man Page：&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>--wrap=symbol&lt;/code>&lt;br>
Use a wrapper function for symbol. Any undefined reference to symbol will be resolved to &amp;ldquo;&lt;code>__wrap_symbol&lt;/code>&amp;rdquo;. Any undefined reference to &amp;ldquo;&lt;code>__real_symbol&lt;/code>&amp;rdquo; will be resolved to symbol.&lt;/p>
&lt;/blockquote>
&lt;br>
&lt;p>操作步驟：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Caller 寫一個加上 &lt;code>__wrap_&lt;/code> 開頭的函式，用來換掉某一個實作。&lt;/p>
&lt;p>例如替換掉 &lt;code>config_load&lt;/code> 我就要定義一個 &lt;code>__wrap_config_load&lt;/code>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Caller 可以使用加上 &lt;code>__real_&lt;/code> 開頭的函式，就可以呼叫到原始的實作 (Optional)。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>編譯的參數加上 &lt;code>-Wl,--wrap=&amp;lt;symbol&amp;gt;&lt;/code>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>可以用 nm 指令看一下編出來的 &lt;code>.o&lt;/code>&lt;/p>
&lt;p>T: 表示在 Text Section 找得到這個 symbol&lt;/p>
&lt;p>U: 表示這個 symbol 是 undefined&lt;/p>
&lt;pre tabindex="0">&lt;code># nm config.o
0000000000000000 T config_load
U fclose
U fopen
U fseek
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code># nm foo.o
U config_load
0000000000000000 T foo
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code># nm main.o
0000000000000000 T __wrap_config_load
U foo
0000000000000011 T main
U puts
&lt;/code>&lt;/pre>&lt;br>
&lt;h2 id="常犯錯誤">常犯錯誤&lt;/h2>
&lt;p>如果 &lt;code>config_load&lt;/code> 定義在 &lt;code>foo.c&lt;/code> 裡面，試著跑看看：&lt;/p>
&lt;pre tabindex="0">&lt;code># make main
gcc -c main.c
gcc -c foo.c
gcc -Wl,--wrap=config_load -o main main.o foo.o
# ./main
Segmentation fault
&lt;/code>&lt;/pre>&lt;p>結果這樣是不行的，用 nm 查看：&lt;/p>
&lt;pre tabindex="0">&lt;code># nm foo.o
0000000000000011 T config_load
U fclose
0000000000000000 T foo
U fopen
U fseek
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code># nm main.o
0000000000000000 T __wrap_config_load
U foo
0000000000000011 T main
U puts
&lt;/code>&lt;/pre>&lt;p>要把 ld 告訴我們的使用方法放在心上：&lt;/p>
&lt;blockquote>
&lt;p>Any undefined reference to symbol will be resolved to &amp;ldquo;&lt;code>__wrap_symbol&lt;/code>&amp;rdquo;&lt;/p>
&lt;/blockquote>
&lt;p>呼叫 &lt;code>config_load&lt;/code> 並不是 undefined，&lt;/p>
&lt;p>所以這告訴我們實作 &amp;amp; 寫測試的時候把要 Mock 的東西切出去，&lt;/p>
&lt;p>就可以用這個手法來替換掉實作，也就是說要把相依但是職責不應該屬於我的 Code 另外放。&lt;/p>
&lt;br>
&lt;h2 id="另外一個方法-ifndef--define--endif">另外一個方法： &lt;code>#ifndef ... #define ... #endif&lt;/code>&lt;/h2>
&lt;p>延伸自 &lt;code>undefined&lt;/code> 的想法，我們也可以直接改寫 &lt;code>foo.c&lt;/code>&lt;/p>
&lt;p>&lt;code>foo.c&lt;/code>&lt;/p>
&lt;pre tabindex="0">&lt;code>#include &amp;#34;stdio.h&amp;#34;
#include &amp;#34;config.h&amp;#34;
#include &amp;#34;foo.h&amp;#34;
#ifndef config_load
#define config_load() my_config_load()
#endif
void my_config_load() {
printf(&amp;#34;wrap\n&amp;#34;);
}
void foo() {
config_load();
}
&lt;/code>&lt;/pre>&lt;p>&lt;code>main.c&lt;/code>&lt;/p>
&lt;pre tabindex="0">&lt;code>#include &amp;#34;foo.h&amp;#34;
int main() {
foo();
return 0;
}
&lt;/code>&lt;/pre>&lt;p>&lt;code>Makefile&lt;/code>&lt;/p>
&lt;pre tabindex="0">&lt;code>config.o:
gcc -c config.c
foo.o:
gcc -c foo.c
main.o:
gcc -c main.c
main: main.o foo.o config.o
gcc -o main main.o foo.o config.o
clean:
rm *.o main
&lt;/code>&lt;/pre>&lt;br>
&lt;p>應該是可以搭配 Target-specific Variable Values 編出 production / development 的 &lt;code>foo.o&lt;/code>&lt;/p>
&lt;p>感謝大神同事給的參考資料：&lt;/p>
&lt;p>&lt;a href="https://www.gnu.org/software/make/manual/html_node/Target_002dspecific.html">Target-specific (GNU make)&lt;/a>&lt;/p>
&lt;br>
&lt;h2 id="參考資料">參考資料&lt;/h2>
&lt;p>&lt;a href="https://stackoverflow.com/questions/31156327/how-to-mock-function-in-c-when-its-caller-function-is-defined-in-same-file">How to mock function in C when its caller function is defined in same file?&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://stackoverflow.com/questions/617554/override-a-function-call-in-c">Override a function call in C&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://stackoverflow.com/questions/43183060/how-to-wrap-existing-function-in-c">How to wrap existing function in C&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://orionlin.pixnet.net/blog/post/96013596-wrap-function%E7%9A%84%E4%BD%BF%E7%94%A8">wrap function的使用 @ Orion&amp;rsquo;s blog :: 痞客邦 ::&lt;/a>&lt;/p>
- https://krapshsa.github.io/posts/c-mock-wrapper-function-87728a4c-9871-48d0-9b84-24dc3483bce4/ - © 2007 - 2022 krapshsa</description></item><item><title>C Unit Test - Criterion 簡單範例</title><link>https://krapshsa.github.io/posts/c-unit-test-criterion-eb7169c5-0a5e-4e8d-b9b5-04a8aa841ba1/</link><pubDate>Fri, 05 Aug 2022 01:52:00 +0800</pubDate><guid>https://krapshsa.github.io/posts/c-unit-test-criterion-eb7169c5-0a5e-4e8d-b9b5-04a8aa841ba1/</guid><description>KRAPSHSA'S BLOG https://krapshsa.github.io/posts/c-unit-test-criterion-eb7169c5-0a5e-4e8d-b9b5-04a8aa841ba1/ -&lt;h2 id="起因">起因&lt;/h2>
&lt;p>要用一個公司很久以前自己寫的 C Lib，沒有文件所以不知道行為是什麼。&lt;/p>
&lt;p>使用的過程中有發現問題，就進行一些修正。&lt;/p>
&lt;p>想說幫他加上一些測試案例，幫助之後要使用的人。&lt;/p>
&lt;br>
&lt;h2 id="環境">環境&lt;/h2>
&lt;h3 id="建置方法">建置方法&lt;/h3>
&lt;p>由於公司是用 CentOS / RHEL / Oracle，我挑了一個差不多的 image 來建 CI&lt;/p>
&lt;p>重點是 rpm 我從 github 上面裝，就可以直接 &lt;code>-l&lt;/code> 使用他的 Lib&lt;/p>
&lt;p>其他是這個 C lib 需要的其他 Lib，跟底下範例無關&lt;/p>
&lt;br>
&lt;p>&lt;code>Dockerfile&lt;/code>&lt;/p>
&lt;pre tabindex="0">&lt;code>FROM oraclelinux:8.6
RUN yum install -y gcc make pcre pcre-devel
RUN yum --enablerepo=ol8_codeready_builder install -y glibc glibc-common glibc-devel glibc-headers glibc-static
RUN rpm -ivh https://github.com/samber/criterion-rpm-package/releases/download/2.3.3/libcriterion-devel-2.3.3-2.el7.x86_64.rpm
&lt;/code>&lt;/pre>&lt;br>
&lt;h2 id="code">Code&lt;/h2>
&lt;p>&lt;code>sut.h&lt;/code>&lt;/p>
&lt;pre tabindex="0">&lt;code>#ifndef TEST_CRITERION_SUT_H
#define TEST_CRITERION_SUT_H
typedef struct result
{
char *begin;
} Result;
extern int doSomething(char *pContent, Result **ppResult);
extern void sutFree(Result **ppResult);
#endif //TEST_CRITERION_SUT_H
&lt;/code>&lt;/pre>&lt;br>
&lt;p>&lt;code>sut.c&lt;/code>&lt;/p>
&lt;pre tabindex="0">&lt;code>#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;#34;sut.h&amp;#34;
int doSomething(char *pContent, Result **ppResult)
{
if (0 == strcmp(pContent, &amp;#34;INPUT_1&amp;#34;)) {
*ppResult = (Result*)malloc(sizeof(Result));
(*ppResult)-&amp;gt;begin = &amp;#34;OUTPUT_1&amp;#34;;
return 1;
}
return 0;
}
void sutFree(Result **ppResult)
{
if(ppResult != NULL &amp;amp;&amp;amp; *ppResult != NULL) {
free(*ppResult);
*ppResult = NULL;
}
}
&lt;/code>&lt;/pre>&lt;br>
&lt;p>&lt;code>test.c&lt;/code>&lt;/p>
&lt;pre tabindex="0">&lt;code>#include &amp;lt;string.h&amp;gt;
#include &amp;lt;criterion/criterion.h&amp;gt;
#include &amp;#34;sut.h&amp;#34;
int ret = 0;
int rule = -1;
Result *s = NULL;
void setup(void) {
ret = 0;
rule = -1;
s = NULL;
}
void teardown(void) {
if (NULL != s) {
sutFree(&amp;amp;s);
}
}
void givenContent(char *content) {
ret = doSomething(content, &amp;amp;s);
}
void returnValueShouldBeSuccess() {
cr_assert(ret &amp;gt; 0);
}
void returnValueShouldBeFailed() {
cr_assert(ret &amp;lt;= 0);
}
void matchContentShouldBe(char *result) {
cr_assert_eq(0, strcmp(result, s-&amp;gt;begin));
}
TestSuite(single_rule_suite, .init = setup, .fini = teardown);
Test(single_rule_suite, test_success) {
givenContent(&amp;#34;INPUT_1&amp;#34;);
returnValueShouldBeSuccess();
matchContentShouldBe(&amp;#34;OUTPUT_1&amp;#34;);
}
Test(single_rule_suite, test_failed) {
givenContent(&amp;#34;INPUT_2&amp;#34;);
returnValueShouldBeFailed();
}
&lt;/code>&lt;/pre>&lt;br>
&lt;p>&lt;code>Makefile&lt;/code>&lt;/p>
&lt;pre tabindex="0">&lt;code>CC = gcc -Wall
sut.o: sut.c
${CC} -c sut.c
test.o: test.c
${CC} -c test.c
test: clean test.o sut.o
${CC} -o test test.o sut.o -lcriterion
./test
clean:
rm -f *.o
&lt;/code>&lt;/pre>&lt;br>
&lt;h2 id="結果">結果&lt;/h2>
&lt;pre tabindex="0">&lt;code>./test
[====] Synthesis: Tested: 2 | Passing: 2 | Failing: 0 | Crashing: 0
&lt;/code>&lt;/pre>&lt;br>
&lt;h2 id="簡易說明">簡易說明&lt;/h2>
&lt;p>&lt;a href="https://criterion.readthedocs.io/en/master/starter.html?highlight=suite#configuration-reference">Getting started - Criterion 2.4.1-rc-1-g56f8f1a-dirty documentation&lt;/a>&lt;/p>
&lt;br>
&lt;h3 id="test-基本用法">Test 基本用法&lt;/h3>
&lt;pre tabindex="0">&lt;code>Test(suite_name, test_name, .init = setup, .fini = teardown) {
// test contents
}
&lt;/code>&lt;/pre>&lt;br>
&lt;h3 id="test-suite-基本用法">Test Suite 基本用法&lt;/h3>
&lt;p>官方給出的例子&lt;/p>
&lt;pre tabindex="0">&lt;code>TestSuite(suite_name, [params...]);
Test(suite_name, test_1) {
}
Test(suite_name, test_2) {
}
&lt;/code>&lt;/pre>&lt;br>
&lt;p>我實際上是這樣用：&lt;/p>
&lt;pre tabindex="0">&lt;code>TestSuite(single_rule_suite, .init = setup, .fini = teardown);
Test(single_rule_suite, test_success) {
...
}
Test(single_rule_suite, test_failed) {
...
}
&lt;/code>&lt;/pre>&lt;p>因為大家的初始化跟銷毀都一樣，不需要在 &lt;code>Test&lt;/code> 裡面重複寫&lt;/p>
&lt;br>
&lt;h2 id="參考資料">參考資料&lt;/h2>
- https://krapshsa.github.io/posts/c-unit-test-criterion-eb7169c5-0a5e-4e8d-b9b5-04a8aa841ba1/ - © 2007 - 2022 krapshsa</description></item><item><title>記一次 MariaDB CPU Loading 滿載查修過程</title><link>https://krapshsa.github.io/posts/mariadb-cpu-loading-e49af856-cc1f-45bf-9e40-f97a0718d89f/</link><pubDate>Thu, 04 Aug 2022 18:46:00 +0800</pubDate><guid>https://krapshsa.github.io/posts/mariadb-cpu-loading-e49af856-cc1f-45bf-9e40-f97a0718d89f/</guid><description>KRAPSHSA'S BLOG https://krapshsa.github.io/posts/mariadb-cpu-loading-e49af856-cc1f-45bf-9e40-f97a0718d89f/ -&lt;h2 id="起因">起因&lt;/h2>
&lt;p>客戶環境的 MariaDB 把 CPU Resource 都吃滿了，&lt;/p>
&lt;p>用 &lt;code>SHOW PROCESSLIST&lt;/code> 查詢有看到好幾條慢的查詢，亂槍打鳥調整了前幾筆都不見改善。&lt;/p>
&lt;p>為了要可以比較精準地改善問題，做了一些研 (goo) 究 (gle)。&lt;/p>
&lt;br>
&lt;h2 id="症狀">症狀&lt;/h2>
&lt;ol>
&lt;li>用 TOP 只看得到 CPU 吃滿，但是記憶體的狀況是 OK 的&lt;br>
&lt;img src="Screen_Shot_2022-08-04_at_6-933c0ea7-374b-425e-a8c0-48a7b22d5b20.52.53_PM.png" alt="">&lt;/li>
&lt;li>ATOP 看起來硬碟也不忙，由於服務跟 DB 建在同一台，應該也不是網路問題&lt;br>
&lt;img src="Screen_Shot_2022-08-04_at_6-4c435945-644d-404e-81b1-f95682c8e20e.54.25_PM.png" alt="">&lt;/li>
&lt;li>約好停服務之後，不管三七二十一先 &lt;code>OPTIMIZE TABLE&lt;/code> 也沒有用&lt;/li>
&lt;li>卡住的前幾名都是 UPDATE，一度懷疑是寫入的問題，但是實際找一個測試資料 Insert / Update 都很快，把這個 UPDATE 相關的 Code 拔掉也沒有用。&lt;/li>
&lt;/ol>
&lt;br>
&lt;h2 id="修復流程">修復流程&lt;/h2>
&lt;h3 id="值得參考的流程">值得參考的流程&lt;/h3>
&lt;p>&lt;a href="https://www.percona.com/blog/2020/04/23/a-simple-approach-to-troubleshooting-high-cpu-in-mysql/">A Simple Approach to Troubleshooting High CPU in MySQL - Percona Database Performance Blog&lt;/a>&lt;/p>
&lt;p>參考了 Percona 給出的流程，寫得挺不錯的 👍&lt;/p>
&lt;p>雖然我的 DB 版本太舊了沒有用 (必須要 MariaDB 10.5 以上才有 &lt;code>THREAD_OS_ID&lt;/code> )。&lt;/p>
&lt;p>不過還是講一下，思路是：&lt;/p>
&lt;ol>
&lt;li>單從 pid 只會看到 process 很忙，看不出是哪個 command 很忙，因為是 multi-thread。&lt;/li>
&lt;li>想辦法找到 thread id ，看看是哪個 thread 在忙。&lt;/li>
&lt;li>有 thread id 之後就可以用， &lt;code>performance_schema.threads&lt;/code> 找到 &lt;code>THREAD_OS_ID&lt;/code> 對應的 Command。&lt;/li>
&lt;/ol>
&lt;br>
&lt;h3 id="我的流程">我的流程&lt;/h3>
&lt;p>因為我的 MariaDB 還沒有升級到 10.5，所以我是去看 process list 中比較慢的 query。&lt;/p>
&lt;p>對這些 Query 查看 query plan，最後找到一筆 &lt;code>SELECT&lt;/code> ，在把服務切斷的狀態下就要四秒。&lt;/p>
&lt;pre tabindex="0">&lt;code>describe SELECT * FROM problem_table WHERE id=100 AND `path` LIKE &amp;#39;某個關鍵字%&amp;#39;;
+------+-------------+---------------+------+-------------------------------------------------------+-----------------+---------+-------+---------+-------------+
| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |
+------+-------------+---------------+------+-------------------------------------------------------+-----------------+---------+-------+---------+-------------+
| 1 | SIMPLE | problem_table | ref | index_1,index_2,index_3 | index_3 | 4 | const | 4213770 | Using where |
+------+-------------+---------------+------+-------------------------------------------------------+-----------------+---------+-------+---------+-------------+
&lt;/code>&lt;/pre>&lt;p>看到 &lt;code>index_3&lt;/code> (被我碼掉了) 是 &lt;code>fid&lt;/code>+ &lt;code>extra&lt;/code> 的聯合索引，對 &lt;code>path&lt;/code> 沒有幫助&lt;/p>
&lt;p>覺得應該是沒有適合的 Index，才會這麼久。&lt;/p>
&lt;p>針對 &lt;code>fid&lt;/code> + &lt;code>path&lt;/code> 去建 Index，最後就解決問題了：&lt;/p>
&lt;pre tabindex="0">&lt;code>create index index_4 on problem_table(field_1,field_2(768));
Query OK, 0 rows affected (1 min 29.487 sec)
describe SELECT * FROM problem_table WHERE fid=100 AND `path` LIKE &amp;#39;某個關鍵字%&amp;#39;;
+------+-------------+---------------+-------+-------------------------------------------------------+-----------------+---------+-------+---------+------------------------------------+
| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |
+------+-------------+---------------+-------+-------------------------------------------------------+-----------------+---------+-------+---------+------------------------------------+
| 1 | SIMPLE | problem_table | range | index_1,index_2,index_3,index_4 | index_4 | 2311 | NULL | 1 | Using index condition; Using where |
+------+-------------+---------------+-------+-------------------------------------------------------+-----------------+---------+-------+---------+------------------------------------+
MariaDB [owncloud]&amp;gt; ELECT * FROM problem_table WHERE fid=100 AND `path` LIKE &amp;#39;某個關鍵字%&amp;#39;;
Empty set (0.000 sec)
&lt;/code>&lt;/pre>&lt;p>SLA 未達承諾是要被罰的，當時這個方法有用就先頂著用了。&lt;/p>
&lt;br>
&lt;h2 id="事後諸葛">事後諸葛&lt;/h2>
&lt;p>在現場時憑著一股直覺，覺得用到 &lt;code>fid&lt;/code> + &lt;code>path&lt;/code> 就去建構這兩個的聯合索引，&lt;/p>
&lt;p>那到底這樣建 index 為什麼有用，要來事後諸葛一下：&lt;/p>
&lt;ol>
&lt;li>&lt;code>fid&lt;/code> 是外來鍵， &lt;code>fid&lt;/code> 為 100 的這個 case，在 DB 中有 400 多萬筆，佔全部的一半 → 基數很小 → 單獨拿來建索引可能沒啥用&lt;/li>
&lt;li>&lt;code>path&lt;/code> 是拿來搜索路徑的，通常都是找該路徑之下的全部 → 用了 &lt;code>LIKE&lt;/code>，但是 &lt;code>%&lt;/code> 在右邊 → Prefix match 是可以用到索引的&lt;/li>
&lt;li>&lt;code>path&lt;/code> 的基數很大 → 建 index 效果不錯&lt;/li>
&lt;li>&lt;code>key_len&lt;/code> 顯示不是只有用到聯合索引中的第一個 (&lt;code>fid&lt;/code>)&lt;/li>
&lt;li>&lt;code>rows&lt;/code> 是 &lt;code>1&lt;/code> 表示只需要掃一行就可以了 (越小越好)&lt;/li>
&lt;li>&lt;code>Extra&lt;/code> 有 &lt;code>Using index&lt;/code> 表示在索引樹中就可以找到資訊，表示還不錯&lt;/li>
&lt;/ol>
&lt;p>有機會可以再做幾個嘗試：&lt;/p>
&lt;ol>
&lt;li>只建 &lt;code>path&lt;/code> 可不可以 → 基數算大，所以想嘗試&lt;/li>
&lt;li>反過來建成 &lt;code>path&lt;/code> + &lt;code>fid&lt;/code> 會不會更好 → 基數大的放前面，想試試看&lt;/li>
&lt;/ol>
&lt;br>
&lt;h2 id="參考資料">參考資料&lt;/h2>
&lt;p>&lt;a href="https://www.jianshu.com/p/57a42f6a8746">MySQL 执行计划 explain plan&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://ithelp.ithome.com.tw/articles/10221971">30-13 之資料庫層的優化 - 索引設計與雷區&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.percona.com/blog/2020/04/23/a-simple-approach-to-troubleshooting-high-cpu-in-mysql/">A Simple Approach to Troubleshooting High CPU in MySQL - Percona Database Performance Blog&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://segmentfault.com/a/1190000008131735">MySQL 性能优化神器 Explain 使用分析&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://opensource.actionsky.com/20210407-mysql/">第25期：索引设计（索引的基数与可选择性） - 爱可生开源社区&lt;/a>&lt;/p>
- https://krapshsa.github.io/posts/mariadb-cpu-loading-e49af856-cc1f-45bf-9e40-f97a0718d89f/ - © 2007 - 2022 krapshsa</description></item><item><title>Windows 上的類 Unix 環境 - Cygwin、MinGW、MSYS</title><link>https://krapshsa.github.io/posts/windows-unix-cygwin-mingw-msys-05707f1a-cacd-4484-9457-7aa26c7cace8/</link><pubDate>Sun, 31 Jul 2022 22:58:00 +0800</pubDate><guid>https://krapshsa.github.io/posts/windows-unix-cygwin-mingw-msys-05707f1a-cacd-4484-9457-7aa26c7cace8/</guid><description>KRAPSHSA'S BLOG https://krapshsa.github.io/posts/windows-unix-cygwin-mingw-msys-05707f1a-cacd-4484-9457-7aa26c7cace8/ -&lt;hr>
&lt;h2 id="起因">起因&lt;/h2>
&lt;p>裝了 CLion，想在 Windows 底下為了在 Windows 上使用 &lt;code>gcc&lt;/code> ，沒有想到竟然如此困難。&lt;/p>
&lt;p>JetBrains IDE 會自動偵測有沒有 Git ，在 Windows 上如果沒有先裝好的話，他就會安裝 Git for Windows。&lt;/p>
&lt;p>Git for Windows 自帶了一個很像 Linux 的環境，但是卻很難用它開始進行 C 的開發。&lt;/p>
&lt;br>
&lt;h2 id="古早味做法">古早味做法&lt;/h2>
&lt;p>&lt;a href="https://zh.wikipedia.org/zh-tw/Dev-C%2B%2B">Dev-C++ - 维基百科，自由的百科全书&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.codeblocks.org/">Code::Blocks&lt;/a>&lt;/p>
&lt;p>Code::Blocks 跟 Dev-C++ 是 Windows 上的 C/C++ IDE，&lt;/p>
&lt;p>剛入門的時候都是用這兩套，裝好就會順便幫你裝 &lt;code>MinGW&lt;/code>。&lt;/p>
&lt;p>反正會動，可以交作業就好，所以當時也沒有很在意到底不同的方案差在哪裡，只知道可能有些東西會編不過。&lt;/p>
&lt;p>&lt;a href="https://stackoverflow.com/questions/33675953/best-way-to-get-around-fork-with-mingw-64">Best way to get around fork() with MingW 64?&lt;/a>&lt;/p>
&lt;p>從 Wiki 上我們可以大概知道這是什麼東西：&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>MinGW&lt;/strong>（&lt;strong>Min&lt;/strong>imalist &lt;strong>G&lt;/strong>NU for &lt;strong>W&lt;/strong>indows），又稱&lt;strong>mingw32&lt;/strong>，是將 &lt;a href="https://zh.wikipedia.org/wiki/GCC">GCC&lt;/a> 編譯器和 &lt;a href="https://zh.wikipedia.org/zh-tw/GNU_Binutils">GNU Binutils&lt;/a> 移植到Win32平台下的產物，包括一系列標頭檔（&lt;a href="https://zh.wikipedia.org/wiki/Windows_API">Win32API&lt;/a>）、&lt;a href="https://zh.wikipedia.org/wiki/%E9%9D%9C%E6%85%8B%E9%80%A3%E7%B5%90%E5%87%BD%E5%BC%8F%E5%BA%AB">函式庫&lt;/a>和&lt;a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6">可執行檔&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>2005年, OneVision Software遵照&lt;a href="https://zh.wikipedia.org/wiki/%E5%87%80%E5%AE%A4%E8%AE%BE%E8%AE%A1">淨室設計&lt;/a>原則，開始開發Mingw-w64，因為最初的MinGW項目更新太慢，遲遲不支持64位環境開發&lt;/p>
&lt;/blockquote>
&lt;p>其他科系的程式設計課用的都是 Visual Studio，用的編譯器是 Visual C++，我沒用過不清楚，&lt;/p>
&lt;p>不過概念應該是相同的，有些東西 Windows API 不支援就不能用，例如 &lt;code>fork()&lt;/code> 。&lt;/p>
&lt;br>
&lt;h2 id="裝-git-on-windows-跑出來的-mingw">裝 git on windows 跑出來的 MinGW&lt;/h2>
&lt;p>&lt;img src="gw1-fef1084f-cd1b-44fc-aae8-ffbf6efd0094.png" alt="">&lt;/p>
&lt;p>現在裝完 git for windows 2.x 之後，就會有一個 git bash 可以用，上面寫著 &lt;code>MINGW64&lt;/code>&lt;/p>
&lt;p>這就是一開始提到的，裝 code::block 或 dev-c++ 可以順便裝的編譯環境。&lt;/p>
&lt;p>既然裝 git 就有，就想要拿來試著開發看看。&lt;/p>
&lt;p>但進到 bash 裡面卻發現沒有 make 可以用，於是就想要模仿 Linux 在上面用套件管理器裝一些套件。&lt;/p>
&lt;p>但是在找資料的過程中發現，很多人都說，git for windows 是搭建在 MSYS / MSYS2 上面，那 MSYS 又是什麼？&lt;/p>
&lt;br>
&lt;h2 id="msys2">MSYS2&lt;/h2>
&lt;p>&lt;a href="https://www.msys2.org/wiki/MSYS2-introduction/">MSYS2 - MSYS2-Introduction&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.msys2.org/wiki/How-does-MSYS2-differ-from-Cygwin/">MSYS2 - How does MSYS2 differ from Cygwin?&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>MSYS2 is software distribution and a building platform for Windows.&lt;br>
It provides a Unix-like environment, a command-line interface and a software repository making it easier to install, use, build and port software on Windows.&lt;br>
That means Bash, Autotools, Make, Git, GCC, GDB&amp;hellip;, all easily installable through Pacman, a fully-featured package manager.&lt;br>
It is an independent rewrite of MSys, based on modern Cygwin (POSIX compatibility layer) and MinGW-w64 with the aim of better interoperability with native Windows software.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>MSYS2 consists of three subsystems and their corresponding package repositories, &lt;code>msys2&lt;/code>, &lt;code>mingw32&lt;/code>, and &lt;code>mingw64&lt;/code>.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>The &lt;code>mingw&lt;/code> subsystems provide native Windows programs and are the main focus of the project.&lt;br>
These programs are built to co-operate well with other Windows programs, independently of the other subsystems.&lt;br>
This part builds on the MinGW-w64 project.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>The &lt;code>msys2&lt;/code> subsystem provides an emulated mostly-POSIX-compliant environment for building software, package management, and shell scripting.&lt;br>
These programs live in a virtual single-root filesystem (the root is the MSYS2 installation directory).&lt;br>
Some effort is made to have the programs work well with native Windows programs, but it&amp;rsquo;s not seamless. This part builds on the Cygwin project.&lt;/p>
&lt;/blockquote>
&lt;p>這邊寫 MSYS2 有兩大類的子系統：&lt;/p>
&lt;ul>
&lt;li>MinGW - 移植的 GCC 編譯器與工具鏈，屬於 Windows 原生。&lt;/li>
&lt;li>MSYS2 - 基於 Cygwin 改寫，屬於模擬 POSIX&lt;/li>
&lt;/ul>
&lt;br>
&lt;p>MSYS2 可以用 &lt;code>pacman&lt;/code> 作為套件管理工具，但是 Git for Windows 上沒有。如果裝 Git for Windows SDK 的話就會有，但是很肥。&lt;/p>
&lt;p>有嘗試著下載安裝包直接裝在系統上，不過卡了一個 zstd 很麻煩，但那就是另外一個故事了。&lt;/p>
&lt;p>最後我自己裝了 MSYS2 ，跟 Git 分開來，就可以順利的編譯了。&lt;/p>
&lt;p>不過好像還有另外一個選擇，以前在學校有看老師用過，就是剛剛提到的 Cygwin。&lt;/p>
&lt;br>
&lt;h2 id="更像-unix-的環境---cygwin">更像 Unix 的環境 - Cygwin&lt;/h2>
&lt;p>&lt;img src="512px-Cygwin_logo-8cee2851-62bc-4926-a7ac-9b61b81091dc.svg.png" alt="">&lt;/p>
&lt;h3 id="what-is-it">What is it?&lt;/h3>
&lt;p>摘自官網&lt;/p>
&lt;blockquote>
&lt;p>Cygwin is:&lt;/p>
&lt;ul>
&lt;li>a large collection of GNU and Open Source tools which provide functionality similar to a &lt;a href="https://en.wikipedia.org/wiki/Linux_distribution">Linux distribution&lt;/a> on Windows.&lt;/li>
&lt;li>a DLL (cygwin1.dll) which provides substantial POSIX API functionality.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;ul>
&lt;li>一個 GNU 和開源工具的大集合，在 Windows 上提供類似 Linux 發行版的功能&lt;/li>
&lt;li>&lt;code>cygwin1.dll&lt;/code> 提供大量 POSIX API 的功能&lt;/li>
&lt;/ul>
&lt;br>
&lt;blockquote>
&lt;p>Cygwin is not:&lt;/p>
&lt;ul>
&lt;li>a way to run native Linux apps on Windows. You must rebuild your application &lt;em>from source&lt;/em> if you want it to run on Windows.&lt;/li>
&lt;li>a way to magically make native Windows apps aware of UNIX® functionality like signals, ptys, etc. Again, you need to build your apps &lt;em>from source&lt;/em> if you want to take advantage of Cygwin functionality.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;ul>
&lt;li>不是在 Windows 上跑 Linux 原生程式的方法。要可以跑，要從原始碼重新 Build。&lt;/li>
&lt;li>一種讓 Windows 程式可以神奇地使用 Unix 功能的方法，但是要從原始碼重新 Build。&lt;/li>
&lt;/ul>
&lt;p>重點就是 &lt;code>cygwin1.dll&lt;/code> ，模擬了很多 Unix 功能，其實 Build 出來的是連結了這個 dll 的 windows 程式。&lt;/p>
&lt;p>與 MinGW 與 Cygwin 的異同，在 wiki 上可以找得到，摘自 Wiki：&lt;/p>
&lt;blockquote>
&lt;p>Cygwin 與 MinGW 皆可用來移植 Unix 軟體到 Windows，但它們採用截然不同的實作。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Cygwin 旨在提供一個完整的 &lt;a href="https://zh.wikipedia.org/wiki/POSIX">POSIX&lt;/a> 層，包括主流 Unix 的系統呼叫及函式庫實作；其重視相容性優先於效能。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>相對的，MinGW 則著重簡化與效能。因此，它並不提供某些難以用 Windows API 實作的 POSIX API，例如 &lt;code>fork()&lt;/code>，&lt;code>mmap()&lt;/code> 和 &lt;code>ioctl()&lt;/code>。&lt;/p>
&lt;/blockquote>
&lt;p>據說有一些效能問題，而且也不確定是不是 100% 模擬。但是拿來通過大一的程式設計課是綽綽有餘的。&lt;/p>
&lt;p>到之後的高等程式設計，大家就直接在 Unix 環境底下作業了。&lt;/p>
&lt;p>&lt;img src="81Ywze2ijaL-a9de5dc3-85a0-4348-99b0-6e26fe4b45e3.jpg" alt="">&lt;/p>
&lt;br>
&lt;h2 id="關係圖">關係圖&lt;/h2>
&lt;p>Stack Overflow 上大神整理好的關係圖，我覺得很清楚&lt;/p>
&lt;p>&lt;img src="apNVx-5bde4d7b-cfe8-403f-b9ba-f1a06680519a.png" alt="">&lt;/p>
&lt;br>
&lt;h2 id="也許是更好的方案wsl2">也許是更好的方案：WSL2&lt;/h2>
&lt;p>&lt;a href="https://www.v2ex.com/t/793055">某些场景下 wsl2 的文件系统简直蛋疼的不行 - V2EX&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://docs.microsoft.com/zh-tw/windows/wsl/tutorials/gui-apps">使用 WSL 執行 Linux GUI 應用程式&lt;/a>&lt;/p>
&lt;p>既然在 Windows 上開發 Unix 程式，環境這麼不好搞定，那就乾脆 toolchain 放在 VM 之類的環境裡面。&lt;/p>
&lt;p>搜尋了一下有滿多人在抱怨如果要把編譯環境放在 WSL 裡面，但是用 Windows 上的編輯器 / IDE 開發很不順手 (路徑轉換、效能問題 …)。&lt;/p>
&lt;blockquote>
&lt;p>不在 wsl2 里安装 ide 的话，lz 的问题永远解决不了&lt;br>
本身跨虚拟机宿主机之间的文件交互性能就很差，你一定要在 Windows 下读 WSL2 的文件或 WSL2 读 Windows 都不会有好体验的&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>lz 你不想在 wsl2 里装 ide 结果就是反倒这是最麻烦的解决办法。而且在 wsl2 里装 IDE 的话，你将能解锁一键完整迁移电脑上的快发环境到别的电脑的隐藏优点。&lt;/p>
&lt;/blockquote>
&lt;p>所幸 JetBrains IDE 是可以裝在 Linux 上的，可以利用 WSL 跑 Linux GUI，或者是跑 JetBrains Gateway 應該都會動。&lt;/p>
&lt;p>正確的姿勢應該是連 IDE 都裝在 WSL 裡面，就可以解決很多 Windows 跟 WSL 溝通得困難。&lt;/p>
&lt;p>如果 Server 不夠強，或是怕桌機太閒了可以試試看這個方法，應該可以解決掉很多問題 (例如：不能用 rsync ，權限不一樣，換行符號不一樣 …)&lt;/p>
&lt;br>
&lt;h2 id="番外在-git-bash-上裝額外的東西是很麻煩的">番外：在 Git Bash 上裝額外的東西是很麻煩的&lt;/h2>
&lt;p>以 &lt;code>rsync&lt;/code> 為例，想要在 Git Bash 上使用 &lt;code>rsync&lt;/code> ，可以直接把 binary 跟 dll 丟進去就好了&lt;/p>
&lt;p>&lt;a href="https://packages.msys2.org/package/rsync?repo=msys&amp;amp;variant=x86_64">Package: rsync - MSYS2 Packages&lt;/a>&lt;/p>
&lt;p>但是他的副檔名是 &lt;code>.tar.zst&lt;/code>，這是 facebook 開發的一種壓縮格式，目前 windows 官方的解壓縮跟官方版本的 7z 都還不支援。&lt;/p>
&lt;p>我們可以去 github 下載 windows 版的 &lt;code>zstd.exe&lt;/code> 就可以在 zstd 的目錄中，從 cmd 解開得到 tar 檔：&lt;/p>
&lt;pre tabindex="0">&lt;code>.\zstd.exe -d rsync-3.2.3-2-x86_64.pkg.tar.zst
&lt;/code>&lt;/pre>&lt;p>&lt;a href="https://github.com/facebook/zstd/releases">Releases · facebook/zstd&lt;/a>&lt;/p>
&lt;p>把解出來的內容丟到 git 的目錄下，例如我的是： &lt;code>C:\Program Files\Git&lt;/code>&lt;/p>
&lt;p>但是這樣還是跑不起來，原因就是它還有缺相依的 dll，所以下載兩個相依的 dll 如法炮製：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>libzstd&lt;/p>
&lt;p>&lt;a href="https://packages.msys2.org/package/libzstd?repo=msys&amp;amp;variant=x86_64">Package: libzstd - MSYS2 Packages&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>libxxhash&lt;/p>
&lt;p>&lt;a href="https://packages.msys2.org/package/libxxhash?repo=msys&amp;amp;variant=x86_64">Package: libxxhash - MSYS2 Packages&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;br>
&lt;h2 id="參考資料">參考資料&lt;/h2>
&lt;p>&lt;a href="https://stackoverflow.com/questions/25019057/how-are-msys-msys2-and-msysgit-related-to-each-other">How are msys, msys2, and msysgit related to each other?&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/360773277">Cygwin vs MinGW vs MSYS2&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://stackoverflow.com/questions/43146372/how-why-cygwin-breaks-windows-permissions">How/why cygwin breaks windows permissions?&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/u012408797/article/details/120490201">POSIX、Cygwin、MSYS、MSYS2、MinGW、MinGW-w64的区别_deparks的博客-CSDN博客_msys msys2&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://blog.zengrong.net/post/cygwin_and_mingw/">Cygwin 与 MinGW/MSYS/MSYS2，如何选择？&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.msys2.org/wiki/How-does-MSYS2-differ-from-Cygwin/">MSYS2 - How does MSYS2 differ from Cygwin?&lt;/a>&lt;/p>
- https://krapshsa.github.io/posts/windows-unix-cygwin-mingw-msys-05707f1a-cacd-4484-9457-7aa26c7cace8/ - © 2007 - 2022 krapshsa</description></item><item><title>docker stack rm 在有 fluentd 的時候總有服務關不掉</title><link>https://krapshsa.github.io/posts/docker-stack-rm-fluentd-3c0047b9-a458-4700-a6f2-b41dcd7da96d/</link><pubDate>Thu, 28 Jul 2022 16:19:00 +0800</pubDate><guid>https://krapshsa.github.io/posts/docker-stack-rm-fluentd-3c0047b9-a458-4700-a6f2-b41dcd7da96d/</guid><description>KRAPSHSA'S BLOG https://krapshsa.github.io/posts/docker-stack-rm-fluentd-3c0047b9-a458-4700-a6f2-b41dcd7da96d/ -&lt;p>最近把 &lt;code>fluentd&lt;/code> 加入到 docker swarm 中當作 Log Driver 的時候，&lt;/p>
&lt;p>移除 docker stack 時，關閉得比較慢的 service 有機會沒辦法完整移除。&lt;/p>
&lt;p>此時 &lt;code>docker inspect&lt;/code> ， &lt;code>docker rm&lt;/code> 等指令都會卡住。&lt;/p>
&lt;p>唯一的解法就是重啟 docker daemon。&lt;/p>
&lt;p>猜測因為沒辦法保證 &lt;code>fluentd&lt;/code> 在最後一個關閉導致出錯了。&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;/p>
&lt;ol>
&lt;li>移除 docker stack&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>docker stack rm mystack
&lt;/code>&lt;/pre>&lt;ol start="2">
&lt;li>檢查 service 都移除掉了&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>docker service ls
ID NAME MODE REPLICAS IMAGE PORTS
&lt;/code>&lt;/pre>&lt;ol start="3">
&lt;li>發現還有 container 沒有正常關閉，且永遠卡在這個狀態&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>docker stack ps mystack --no-trunc
ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS
5fllkwthpur60gzgeqq4cow48 i1i65yn2b35jqsfqk7gb9y7l8.1 my-clamav:2022-0406-145048 localhost.localdomain Remove Running about a minute ago
&lt;/code>&lt;/pre>&lt;p>&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>檢查系統的 Log，有出現如下訊息 (我是 CentOS)：&lt;/p>
&lt;pre tabindex="0">&lt;code>sudo cat /var/log/messages | grep 3c902d2962f7
Jul 28 10:48:49 localhost dockerd[1265564]: time=&amp;#34;2022-07-28T10:48:49.917640954+08:00&amp;#34; level=info msg=&amp;#34;Configured log driver does not support reads, enabling local file cache for container logs&amp;#34; container=3c902d2962f7fb6af8ce5a16a965bd2707383dbb18fed9b6942e1687f6419c4b driver=fluentd
Jul 28 10:48:49 localhost containerd[1161]: time=&amp;#34;2022-07-28T10:48:49.936470840+08:00&amp;#34; level=info msg=&amp;#34;starting signal loop&amp;#34; namespace=moby path=/run/containerd/io.containerd.runtime.v2.task/moby/3c902d2962f7fb6af8ce5a16a965bd2707383dbb18fed9b6942e1687f6419c4b pid=1269465 runtime=io.containerd.runc.v2
Jul 28 10:53:00 localhost dockerd[1265564]: time=&amp;#34;2022-07-28T10:53:00.719182463+08:00&amp;#34; level=info msg=&amp;#34;ignoring event&amp;#34; container=3c902d2962f7fb6af8ce5a16a965bd2707383dbb18fed9b6942e1687f6419c4b module=libcontainerd namespace=moby topic=/tasks/delete type=&amp;#34;*events.TaskDelete&amp;#34;
Jul 28 10:53:00 localhost containerd[1161]: time=&amp;#34;2022-07-28T10:53:00.719579189+08:00&amp;#34; level=info msg=&amp;#34;shim disconnected&amp;#34; id=3c902d2962f7fb6af8ce5a16a965bd2707383dbb18fed9b6942e1687f6419c4b
Jul 28 10:53:00 localhost containerd[1161]: time=&amp;#34;2022-07-28T10:53:00.719667935+08:00&amp;#34; level=warning msg=&amp;#34;cleaning up after shim disconnected&amp;#34; id=3c902d2962f7fb6af8ce5a16a965bd2707383dbb18fed9b6942e1687f6419c4b namespace=moby
Jul 28 10:53:07 localhost dockerd[1265564]: time=&amp;#34;2022-07-28T10:53:07.730207608+08:00&amp;#34; level=info msg=&amp;#34;Container failed to exit within 10s of signal 15 - using the force&amp;#34; container=3c902d2962f7fb6af8ce5a16a965bd2707383dbb18fed9b6942e1687f6419c4b
Jul 28 10:57:07 localhost dockerd[1271313]: time=&amp;#34;2022-07-28T10:57:07.971173522+08:00&amp;#34; level=info msg=&amp;#34;Removing stale sandbox c540d42e6cba844695f8cb780f5c28a82a59500207ace2b6526d11eca5b54600 (3c902d2962f7fb6af8ce5a16a965bd2707383dbb18fed9b6942e1687f6419c4b)&amp;#34;
Jul 28 11:12:19 localhost dockerd[1271313]: time=&amp;#34;2022-07-28T11:12:19.902248293+08:00&amp;#34; level=error msg=&amp;#34;Error getting service 3c902d2962f7: service 3c902d2962f7 not found&amp;#34;
Jul 28 11:12:19 localhost dockerd[1271313]: time=&amp;#34;2022-07-28T11:12:19.905022331+08:00&amp;#34; level=error msg=&amp;#34;Error getting task 3c902d2962f7: task 3c902d2962f7 not found&amp;#34;
Jul 28 11:12:19 localhost dockerd[1271313]: time=&amp;#34;2022-07-28T11:12:19.906474336+08:00&amp;#34; level=error msg=&amp;#34;Error getting node 3c902d2962f7: node 3c902d2962f7 not found&amp;#34;
&lt;/code>&lt;/pre>&lt;p>&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>一開始懷疑是沒有辦法關掉 process，可能在卡在寫 Log 了。&lt;br>
照著這個思路，先去查詢查詢 container 相對應的 pid：&lt;/p>
&lt;pre tabindex="0">&lt;code>docker inspect -f &amp;#39;{{.State.Pid}}&amp;#39; 3c902d2962f7
1269485
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>sudo pstree -a -p
...
|-containerd-shim,1269465 -namespace moby -id 3c902d2962f7fb6af8ce5a16a965bd2707383dbb18fed9b6942e1687f6419c4b -address/run/
| |-docker-init,1269485 -- /bootstrap.sh
| | |-clamd,1269536 -c /etc/clamav/clam.conf
| | | `-{clamd},1269731
| | |-freshclam,1269560 -d -c 6
| | | `-{freshclam},1269732
| | `-gunicorn,1269558 /usr/bin/gunicorn --workers=2 --threads=2 --bind 0.0.0.0:8000 --daemon wsgi:app
| | |-gunicorn,1269561 /usr/bin/gunicorn --workers=2 --threads=2 --bind 0.0.0.0:8000 --daemon wsgi:app
| | `-gunicorn,1269562 /usr/bin/gunicorn --workers=2 --threads=2 --bind 0.0.0.0:8000 --daemon wsgi:app
...
&lt;/code>&lt;/pre>&lt;p>接著移除掉整個 stack。&lt;/p>
&lt;p>但是發現儘管 docker ps 看到 container 還在，但 pid 已經找不到了。&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>看起來這個 container 沒有施力點，只好試試看手動調整關閉 Service 的順序&lt;/p>
&lt;p>最後寫成腳本：&lt;/p>
&lt;pre tabindex="0">&lt;code>function get_services() {
services=$(docker service ls --format &amp;#34;{{.Name}}&amp;#34; | sed -E &amp;#39;s/mystack_//&amp;#39;)
echo &amp;#34;$services&amp;#34;
}
function down() {
stack_prefix=&amp;#34;mystack_&amp;#34;
last_service=&amp;#34;fluentd&amp;#34;
services=$(get_services)
services=${services[*]/$last_service}
for service in $services
do
docker service rm &amp;#34;$stack_prefix$service&amp;#34; &amp;gt; /dev/null
done
# wait for all containers removed.
for i in {1..60}
do
docker ps -a | grep -v &amp;#34;$stack_prefix$last_service&amp;#34; | grep -q &amp;#34;$stack_prefix&amp;#34;
if [ $? -eq 1 ]; then
docker service rm &amp;#34;$stack_prefix$last_service&amp;#34; &amp;gt; /dev/null
break
fi
sleep 1
done
if [[ &amp;#34;60&amp;#34; -eq &amp;#34;$i&amp;#34; ]]; then
exit 1
fi
for i in {1..60}
do
docker ps -a | grep -q &amp;#34;$stack_prefix&amp;#34;
if [ $? -eq 1 ]; then
break
fi
sleep 1
done
if [[ &amp;#34;60&amp;#34; -eq &amp;#34;$i&amp;#34; ]]; then
exit 1
fi
}
down
&lt;/code>&lt;/pre>&lt;p>&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;/p>
- https://krapshsa.github.io/posts/docker-stack-rm-fluentd-3c0047b9-a458-4700-a6f2-b41dcd7da96d/ - © 2007 - 2022 krapshsa</description></item><item><title>使用 container 在同一個 stack 部屬 log driver 時，docker stack rm 經常性失敗</title><link>https://krapshsa.github.io/posts/container-stack-log-driver-docker-stack-rm-3c0047b9-a458-4700-a6f2-b41dcd7da96d/</link><pubDate>Thu, 28 Jul 2022 16:19:00 +0800</pubDate><guid>https://krapshsa.github.io/posts/container-stack-log-driver-docker-stack-rm-3c0047b9-a458-4700-a6f2-b41dcd7da96d/</guid><description>KRAPSHSA'S BLOG https://krapshsa.github.io/posts/container-stack-log-driver-docker-stack-rm-3c0047b9-a458-4700-a6f2-b41dcd7da96d/ -&lt;h2 id="起因">起因&lt;/h2>
&lt;p>最近把 &lt;code>fluentd&lt;/code> 加入到 docker swarm 中當作 Log Driver 的時候，&lt;/p>
&lt;p>移除 docker stack 時，關閉得比較慢的 service 有機會沒辦法完整移除。&lt;/p>
&lt;p>此時 &lt;code>docker inspect&lt;/code> ， &lt;code>docker rm&lt;/code> 等指令都會卡住。&lt;/p>
&lt;p>唯一的解法就是重啟 docker daemon。&lt;/p>
&lt;p>猜測因為沒辦法保證 &lt;code>fluentd&lt;/code> 在最後一個關閉導致出錯了。&lt;/p>
&lt;br>
&lt;h2 id="重製步驟">重製步驟&lt;/h2>
&lt;ol>
&lt;li>移除 docker stack&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>docker stack rm mystack
&lt;/code>&lt;/pre>&lt;ol start="2">
&lt;li>檢查 service 都移除掉了&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>docker service ls
ID NAME MODE REPLICAS IMAGE PORTS
&lt;/code>&lt;/pre>&lt;ol start="3">
&lt;li>發現還有 container 沒有正常關閉，且永遠卡在這個狀態&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>docker stack ps mystack --no-trunc
ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS
5fllkwthpur60gzgeqq4cow48 i1i65yn2b35jqsfqk7gb9y7l8.1 my-clamav:2022-0406-145048 localhost.localdomain Remove Running about a minute ago
&lt;/code>&lt;/pre>&lt;br>
&lt;p>檢查系統的 Log，有出現如下訊息 (我是 CentOS)：&lt;/p>
&lt;pre tabindex="0">&lt;code>sudo cat /var/log/messages | grep 3c902d2962f7
Jul 28 10:48:49 localhost dockerd[1265564]: time=&amp;#34;2022-07-28T10:48:49.917640954+08:00&amp;#34; level=info msg=&amp;#34;Configured log driver does not support reads, enabling local file cache for container logs&amp;#34; container=3c902d2962f7fb6af8ce5a16a965bd2707383dbb18fed9b6942e1687f6419c4b driver=fluentd
Jul 28 10:48:49 localhost containerd[1161]: time=&amp;#34;2022-07-28T10:48:49.936470840+08:00&amp;#34; level=info msg=&amp;#34;starting signal loop&amp;#34; namespace=moby path=/run/containerd/io.containerd.runtime.v2.task/moby/3c902d2962f7fb6af8ce5a16a965bd2707383dbb18fed9b6942e1687f6419c4b pid=1269465 runtime=io.containerd.runc.v2
Jul 28 10:53:00 localhost dockerd[1265564]: time=&amp;#34;2022-07-28T10:53:00.719182463+08:00&amp;#34; level=info msg=&amp;#34;ignoring event&amp;#34; container=3c902d2962f7fb6af8ce5a16a965bd2707383dbb18fed9b6942e1687f6419c4b module=libcontainerd namespace=moby topic=/tasks/delete type=&amp;#34;*events.TaskDelete&amp;#34;
Jul 28 10:53:00 localhost containerd[1161]: time=&amp;#34;2022-07-28T10:53:00.719579189+08:00&amp;#34; level=info msg=&amp;#34;shim disconnected&amp;#34; id=3c902d2962f7fb6af8ce5a16a965bd2707383dbb18fed9b6942e1687f6419c4b
Jul 28 10:53:00 localhost containerd[1161]: time=&amp;#34;2022-07-28T10:53:00.719667935+08:00&amp;#34; level=warning msg=&amp;#34;cleaning up after shim disconnected&amp;#34; id=3c902d2962f7fb6af8ce5a16a965bd2707383dbb18fed9b6942e1687f6419c4b namespace=moby
Jul 28 10:53:07 localhost dockerd[1265564]: time=&amp;#34;2022-07-28T10:53:07.730207608+08:00&amp;#34; level=info msg=&amp;#34;Container failed to exit within 10s of signal 15 - using the force&amp;#34; container=3c902d2962f7fb6af8ce5a16a965bd2707383dbb18fed9b6942e1687f6419c4b
Jul 28 10:57:07 localhost dockerd[1271313]: time=&amp;#34;2022-07-28T10:57:07.971173522+08:00&amp;#34; level=info msg=&amp;#34;Removing stale sandbox c540d42e6cba844695f8cb780f5c28a82a59500207ace2b6526d11eca5b54600 (3c902d2962f7fb6af8ce5a16a965bd2707383dbb18fed9b6942e1687f6419c4b)&amp;#34;
Jul 28 11:12:19 localhost dockerd[1271313]: time=&amp;#34;2022-07-28T11:12:19.902248293+08:00&amp;#34; level=error msg=&amp;#34;Error getting service 3c902d2962f7: service 3c902d2962f7 not found&amp;#34;
Jul 28 11:12:19 localhost dockerd[1271313]: time=&amp;#34;2022-07-28T11:12:19.905022331+08:00&amp;#34; level=error msg=&amp;#34;Error getting task 3c902d2962f7: task 3c902d2962f7 not found&amp;#34;
Jul 28 11:12:19 localhost dockerd[1271313]: time=&amp;#34;2022-07-28T11:12:19.906474336+08:00&amp;#34; level=error msg=&amp;#34;Error getting node 3c902d2962f7: node 3c902d2962f7 not found&amp;#34;
&lt;/code>&lt;/pre>&lt;br>
&lt;h2 id="猜測">猜測&lt;/h2>
&lt;p>一開始懷疑是沒有辦法關掉 process，可能在卡在寫 Log 了。&lt;br>
照著這個思路，先去查詢查詢 container 相對應的 pid：&lt;/p>
&lt;pre tabindex="0">&lt;code>docker inspect -f &amp;#39;{{.State.Pid}}&amp;#39; 3c902d2962f7
1269485
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>sudo pstree -a -p
...
|-containerd-shim,1269465 -namespace moby -id 3c902d2962f7fb6af8ce5a16a965bd2707383dbb18fed9b6942e1687f6419c4b -address/run/
| |-docker-init,1269485 -- /bootstrap.sh
| | |-clamd,1269536 -c /etc/clamav/clam.conf
| | | `-{clamd},1269731
| | |-freshclam,1269560 -d -c 6
| | | `-{freshclam},1269732
| | `-gunicorn,1269558 /usr/bin/gunicorn --workers=2 --threads=2 --bind 0.0.0.0:8000 --daemon wsgi:app
| | |-gunicorn,1269561 /usr/bin/gunicorn --workers=2 --threads=2 --bind 0.0.0.0:8000 --daemon wsgi:app
| | `-gunicorn,1269562 /usr/bin/gunicorn --workers=2 --threads=2 --bind 0.0.0.0:8000 --daemon wsgi:app
...
&lt;/code>&lt;/pre>&lt;p>接著移除掉整個 stack。&lt;/p>
&lt;p>但是發現儘管 &lt;code>docker ps&lt;/code> 看到 container 還在，但 pid 已經找不到了。&lt;/p>
&lt;br>
&lt;h2 id="workaround">Workaround&lt;/h2>
&lt;p>看起來這個 container 沒有施力點，只好試試看手動調整關閉 Service 的順序&lt;/p>
&lt;p>最後寫成腳本：&lt;/p>
&lt;pre tabindex="0">&lt;code>function get_services() {
services=$(docker service ls --format &amp;#34;{{.Name}}&amp;#34; | sed -E &amp;#39;s/mystack_//&amp;#39;)
echo &amp;#34;$services&amp;#34;
}
function down() {
stack_prefix=&amp;#34;mystack_&amp;#34;
last_service=&amp;#34;fluentd&amp;#34;
services=$(get_services)
services=${services[*]/$last_service}
for service in $services
do
docker service rm &amp;#34;$stack_prefix$service&amp;#34; &amp;gt; /dev/null
done
# wait for all containers removed.
for i in {1..60}
do
docker ps -a | grep -v &amp;#34;$stack_prefix$last_service&amp;#34; | grep -q &amp;#34;$stack_prefix&amp;#34;
if [ $? -eq 1 ]; then
docker service rm &amp;#34;$stack_prefix$last_service&amp;#34; &amp;gt; /dev/null
break
fi
sleep 1
done
if [[ &amp;#34;60&amp;#34; -eq &amp;#34;$i&amp;#34; ]]; then
exit 1
fi
for i in {1..60}
do
docker ps -a | grep -q &amp;#34;$stack_prefix&amp;#34;
if [ $? -eq 1 ]; then
break
fi
sleep 1
done
if [[ &amp;#34;60&amp;#34; -eq &amp;#34;$i&amp;#34; ]]; then
exit 1
fi
}
down
&lt;/code>&lt;/pre>&lt;br>
- https://krapshsa.github.io/posts/container-stack-log-driver-docker-stack-rm-3c0047b9-a458-4700-a6f2-b41dcd7da96d/ - © 2007 - 2022 krapshsa</description></item><item><title>OwnCloud MariaDB mysqldump 失敗</title><link>https://krapshsa.github.io/posts/owncloud-mariadb-mysqldump-84758a8c-6502-4c2d-b878-3a97ea0e36a7/</link><pubDate>Wed, 27 Jul 2022 14:58:00 +0800</pubDate><guid>https://krapshsa.github.io/posts/owncloud-mariadb-mysqldump-84758a8c-6502-4c2d-b878-3a97ea0e36a7/</guid><description>KRAPSHSA'S BLOG https://krapshsa.github.io/posts/owncloud-mariadb-mysqldump-84758a8c-6502-4c2d-b878-3a97ea0e36a7/ -&lt;h2 id="起因">起因&lt;/h2>
&lt;p>近期遭遇 &lt;code>mysqldump&lt;/code> 備份 OwnCloud 的 DB 結果 crash 的問題&lt;/p>
&lt;p>google 了一下發現 NextCloud 也有人發生類似的問題&lt;/p>
&lt;p>&lt;a href="https://help.nextcloud.com/t/table-oc-filecache-extended-corrupt/123149">Table &lt;code>oc_filecache_extended&lt;/code> corrupt?&lt;/a>&lt;/p>
&lt;br>
&lt;p>摘錄連結內的錯誤訊息：&lt;/p>
&lt;pre tabindex="0">&lt;code>Thread pointer: 0x8548068d8
Attempting backtrace. You can use the following information to find out
where mysqld died. If you see no messages after this, something went
terribly wrong...
stack_bottom = 0x7fffdf76cf38 thread_stack 0x3c000
0x12fcbfc &amp;lt;my_print_stacktrace+0x3c&amp;gt; at /usr/local/libexec/mariadbd
0xc6330f &amp;lt;handle_fatal_signal+0x28f&amp;gt; at /usr/local/libexec/mariadbd
0x8018f7de0 &amp;lt;pthread_sigmask+0x530&amp;gt; at /lib/libthr.so.3
Trying to get some variables.
Some pointers may be invalid and cause the dump to abort.
Query (0x85484dab0): show fields from `oc_cards`
Connection ID (thread ID): 4
Status: NOT_KILLED
&lt;/code>&lt;/pre>&lt;br>
&lt;p>有問題的語句就是這條：&lt;/p>
&lt;pre tabindex="0">&lt;code>show fields from &amp;lt;TABLE&amp;gt;
&lt;/code>&lt;/pre>&lt;br>
&lt;p>執行檢查，但是結果也全部都是 OK&lt;/p>
&lt;pre tabindex="0">&lt;code>mysqlcheck --all-databases
&lt;/code>&lt;/pre>&lt;br>
&lt;h2 id="workaround">Workaround&lt;/h2>
&lt;p>由於這台機器還有人在用，要想辦法趕快讓服務正常。&lt;/p>
&lt;p>經過多方嘗試，目前有效的做法如下：&lt;/p>
&lt;ol>
&lt;li>開啟一台相同設定的新 DB，為了讓他產生好 DB 基本資料&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>docker run -v ${PWD}/data:/bitnami/mariadb/data -p 3306:3306 -e MARIADB_ROOT_PASSWORD=mypassword -d bitnami/mariadb:10.5.15
&lt;/code>&lt;/pre>&lt;ol start="2">
&lt;li>關閉新 DB&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>docker stop &amp;lt;db 的 id&amp;gt;
&lt;/code>&lt;/pre>&lt;ol start="3">
&lt;li>複製 DB 資料夾下， &lt;code>ibdata1&lt;/code> 與 &lt;code>owncloud&lt;/code> 的資料夾到新 DB 資料夾下&lt;/li>
&lt;li>再次啟動新 DB&lt;/li>
&lt;/ol>
&lt;br>
&lt;p>之後也試著去找出原因，但是連 core file 都沒辦法產生所以沒辦法 GDB。&lt;/p>
&lt;br>
&lt;h2 id="參考資料">參考資料&lt;/h2>
&lt;p>&lt;a href="https://blog.csdn.net/hawht/article/details/84246261">MariaDB Error：1932 Table doesn&amp;rsquo;t exist in engine 的解决方法_u014461454的博客-CSDN博客&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://blog.path8.net/archives/7608.html">MySQL/MariaDB已被锁表运行中热复制为副本/innodb表错误Table xx doesn&amp;rsquo;t exist in engine处理&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://dba.stackexchange.com/questions/62989/how-does-innodb-store-tables-in-ibdata-file">How does InnoDB store tables in ibdata file?&lt;/a>&lt;/p>
- https://krapshsa.github.io/posts/owncloud-mariadb-mysqldump-84758a8c-6502-4c2d-b878-3a97ea0e36a7/ - © 2007 - 2022 krapshsa</description></item><item><title>在 template literal 中使用函數</title><link>https://krapshsa.github.io/posts/template-literal-bea4efe5-2565-42f7-832f-580089f7807d/</link><pubDate>Tue, 21 Jun 2022 16:18:00 +0800</pubDate><guid>https://krapshsa.github.io/posts/template-literal-bea4efe5-2565-42f7-832f-580089f7807d/</guid><description>KRAPSHSA'S BLOG https://krapshsa.github.io/posts/template-literal-bea4efe5-2565-42f7-832f-580089f7807d/ -&lt;h2 id="起因">起因&lt;/h2>
&lt;p>在 Code Review 的時候，同事原本是使用多次字串相接&lt;/p>
&lt;pre tabindex="0">&lt;code>const object1 = {
a: &amp;#39;somestring&amp;#39;,
b: 42
};
let html = `&amp;lt;ul&amp;gt;`;
for (const [key, value] of Object.entries(object1)) {
html += `&amp;lt;li&amp;gt;${key}: ${value}&amp;lt;/li&amp;gt;`;
}
html += `&amp;lt;/ul&amp;gt;`;
&lt;/code>&lt;/pre>&lt;p>後來想要表達出 html 的階層結構，想用使用巢狀的方式使用 template literal&lt;/p>
&lt;br>
&lt;h2 id="解方">解方&lt;/h2>
&lt;p>要用 function 來做的話可以使用 IIFE&lt;/p>
&lt;pre tabindex="0">&lt;code>const object1 = {
a: &amp;#39;somestring&amp;#39;,
b: 42
};
let html = `
&amp;lt;ul&amp;gt;
${
(function(){
let list = &amp;#39;&amp;#39;;
for (const [key, value] of Object.entries(object1)) {
list += `&amp;lt;li&amp;gt;${key}: ${value}&amp;lt;/li&amp;gt;`;
}
return list;
})()
}
&amp;lt;/ul&amp;gt;
`;
&lt;/code>&lt;/pre>&lt;p>以我簡化的例子來說，使用 IIFE 看起來變得更複雜了，&lt;/p>
&lt;p>但是用在比較長的 &lt;code>html&lt;/code> 來說比較能看出結構&lt;/p>
&lt;p>&lt;a href="https://jsfiddle.net/4h2n9L8t/">JSFiddle&lt;/a>&lt;/p>
&lt;br>
&lt;h2 id="參考資料">參考資料&lt;/h2>
&lt;p>&lt;a href="https://flaviocopes.com/javascript-iife/">JavaScript Immediately-invoked Function Expressions (IIFE)&lt;/a>&lt;/p>
- https://krapshsa.github.io/posts/template-literal-bea4efe5-2565-42f7-832f-580089f7807d/ - © 2007 - 2022 krapshsa</description></item></channel></rss>