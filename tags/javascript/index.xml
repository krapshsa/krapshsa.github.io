<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>javascript on KRAPSHSA'S BLOG</title><link>https://krapshsa.github.io/tags/javascript/</link><description>Recent content in javascript on KRAPSHSA'S BLOG</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>© 2007 - 2022 krapshsa</copyright><lastBuildDate>Tue, 21 Jun 2022 16:18:00 +0800</lastBuildDate><atom:link href="https://krapshsa.github.io/tags/javascript/index.xml" rel="self" type="application/rss+xml"/><item><title>在 template literal 中使用函數</title><link>https://krapshsa.github.io/posts/template-literal-bea4efe5-2565-42f7-832f-580089f7807d/</link><pubDate>Tue, 21 Jun 2022 16:18:00 +0800</pubDate><guid>https://krapshsa.github.io/posts/template-literal-bea4efe5-2565-42f7-832f-580089f7807d/</guid><description>在 Code Review 的時候，同事原本是使用多次字串相接
const object1 = { a: &amp;#39;somestring&amp;#39;, b: 42 }; let html = `&amp;lt;ul&amp;gt;`; for (const [key, value] of Object.entries(object1)) { html += `&amp;lt;li&amp;gt;${key}: ${value}&amp;lt;/li&amp;gt;`; } html += `&amp;lt;/ul&amp;gt;`; `; 後來想要表達出 html 的階層結構，想用使用巢狀的方式使用 template literal，
要用 function 來做的話可以使用 IIFE
const object1 = { a: &amp;#39;somestring&amp;#39;, b: 42 }; let html = ` &amp;lt;ul&amp;gt; ${ (function(){ let list = &amp;#39;&amp;#39;; for (const [key, value] of Object.entries(object1)) { list += `&amp;lt;li&amp;gt;${key}: ${value}&amp;lt;/li&amp;gt;`; } return list; })() } &amp;lt;/ul&amp;gt; `; 以我簡化的例子來說，使用 IIFE 看起來變得更複雜了，</description></item></channel></rss>