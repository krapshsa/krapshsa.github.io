<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on KRAPSHSA'S BLOG</title><link>https://krapshsa.github.io/posts/</link><description>Recent content in Posts on KRAPSHSA'S BLOG</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><copyright>© 2007 - 2022 krapshsa</copyright><lastBuildDate>Thu, 04 Aug 2022 18:46:00 +0800</lastBuildDate><atom:link href="https://krapshsa.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>記一次 MariaDB CPU Loading 滿載查修過程</title><link>https://krapshsa.github.io/posts/mariadb-cpu-loading-e49af856-cc1f-45bf-9e40-f97a0718d89f/</link><pubDate>Thu, 04 Aug 2022 18:46:00 +0800</pubDate><guid>https://krapshsa.github.io/posts/mariadb-cpu-loading-e49af856-cc1f-45bf-9e40-f97a0718d89f/</guid><description>起因 客戶環境的 MariaDB 把 CPU Resource 都吃滿了，
用 SHOW PROCESSLIST 查詢有看到好幾條慢的查詢，亂槍打鳥調整了前幾筆都不見改善。
為了要可以比較精準地改善問題，做了一些研 (goo) 究 (gle)。
症狀 用 TOP 只看得到 CPU 吃滿，但是記憶體的狀況是 OK 的 ATOP 看起來硬碟也不忙，由於服務跟 DB 建在同一台，應該也不是網路問題 約好停服務之後，不管三七二十一先 OPTIMIZE TABLE 也沒有用 卡住的前幾名都是 UPDATE，一度懷疑是寫入的問題，但是實際找一個測試資料 Insert / Update 都很快，把這個 UPDATE 相關的 Code 拔掉也沒有用。 修復流程 值得參考的流程 A Simple Approach to Troubleshooting High CPU in MySQL - Percona Database Performance Blog
參考了 Percona 給出的流程，寫得挺不錯的 👍
雖然我的 DB 版本太舊了沒有用 (必須要 MariaDB 10.5 以上才有 THREAD_OS_ID )。</description></item><item><title>Windows 上的類 Unix 環境 - Cygwin、MinGW、MSYS</title><link>https://krapshsa.github.io/posts/windows-unix-cygwin-mingw-msys-05707f1a-cacd-4484-9457-7aa26c7cace8/</link><pubDate>Sun, 31 Jul 2022 22:58:00 +0800</pubDate><guid>https://krapshsa.github.io/posts/windows-unix-cygwin-mingw-msys-05707f1a-cacd-4484-9457-7aa26c7cace8/</guid><description>起因 裝了 CLion，想在 Windows 底下為了在 Windows 上使用 gcc ，沒有想到竟然如此困難。
JetBrains IDE 會自動偵測有沒有 Git ，在 Windows 上如果沒有先裝好的話，他就會安裝 Git for Windows。
Git for Windows 自帶了一個很像 Linux 的環境，但是卻很難用它開始進行 C 的開發。
古早味做法 Dev-C++ - 维基百科，自由的百科全书
Code::Blocks
Code::Blocks 跟 Dev-C++ 是 Windows 上的 C/C++ IDE，
剛入門的時候都是用這兩套，裝好就會順便幫你裝 MinGW。
反正會動，可以交作業就好，所以當時也沒有很在意到底不同的方案差在哪裡，只知道可能有些東西會編不過。
Best way to get around fork() with MingW 64?
從 Wiki 上我們可以大概知道這是什麼東西：
MinGW（Minimalist GNU for Windows），又稱mingw32，是將 GCC 編譯器和 GNU Binutils 移植到Win32平台下的產物，包括一系列標頭檔（Win32API）、函式庫和可執行檔。
2005年, OneVision Software遵照淨室設計原則，開始開發Mingw-w64，因為最初的MinGW項目更新太慢，遲遲不支持64位環境開發
其他科系的程式設計課用的都是 Visual Studio，用的編譯器是 Visual C++，我沒用過不清楚，</description></item><item><title>docker stack rm 在有 fluentd 的時候總有服務關不掉</title><link>https://krapshsa.github.io/posts/docker-stack-rm-fluentd-3c0047b9-a458-4700-a6f2-b41dcd7da96d/</link><pubDate>Thu, 28 Jul 2022 16:19:00 +0800</pubDate><guid>https://krapshsa.github.io/posts/docker-stack-rm-fluentd-3c0047b9-a458-4700-a6f2-b41dcd7da96d/</guid><description>最近把 fluentd 加入到 docker swarm 中當作 Log Driver 的時候，
移除 docker stack 時，關閉得比較慢的 service 有機會沒辦法完整移除。
此時 docker inspect ， docker rm 等指令都會卡住。
唯一的解法就是重啟 docker daemon。
猜測因為沒辦法保證 fluentd 在最後一個關閉導致出錯了。
移除 docker stack docker stack rm mystack 檢查 service 都移除掉了 docker service ls ID NAME MODE REPLICAS IMAGE PORTS 發現還有 container 沒有正常關閉，且永遠卡在這個狀態 docker stack ps mystack --no-trunc ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS 5fllkwthpur60gzgeqq4cow48 i1i65yn2b35jqsfqk7gb9y7l8.1 my-clamav:2022-0406-145048 localhost.localdomain Remove Running about a minute ago 檢查系統的 Log，有出現如下訊息 (我是 CentOS)：</description></item><item><title>使用 container 在同一個 stack 部屬 log driver 時，docker stack rm 經常性失敗</title><link>https://krapshsa.github.io/posts/container-stack-log-driver-docker-stack-rm-3c0047b9-a458-4700-a6f2-b41dcd7da96d/</link><pubDate>Thu, 28 Jul 2022 16:19:00 +0800</pubDate><guid>https://krapshsa.github.io/posts/container-stack-log-driver-docker-stack-rm-3c0047b9-a458-4700-a6f2-b41dcd7da96d/</guid><description>起因 最近把 fluentd 加入到 docker swarm 中當作 Log Driver 的時候，
移除 docker stack 時，關閉得比較慢的 service 有機會沒辦法完整移除。
此時 docker inspect ， docker rm 等指令都會卡住。
唯一的解法就是重啟 docker daemon。
猜測因為沒辦法保證 fluentd 在最後一個關閉導致出錯了。
重製步驟 移除 docker stack docker stack rm mystack 檢查 service 都移除掉了 docker service ls ID NAME MODE REPLICAS IMAGE PORTS 發現還有 container 沒有正常關閉，且永遠卡在這個狀態 docker stack ps mystack --no-trunc ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS 5fllkwthpur60gzgeqq4cow48 i1i65yn2b35jqsfqk7gb9y7l8.1 my-clamav:2022-0406-145048 localhost.</description></item><item><title>OwnCloud MariaDB mysqldump 失敗</title><link>https://krapshsa.github.io/posts/owncloud-mariadb-mysqldump-84758a8c-6502-4c2d-b878-3a97ea0e36a7/</link><pubDate>Wed, 27 Jul 2022 14:58:00 +0800</pubDate><guid>https://krapshsa.github.io/posts/owncloud-mariadb-mysqldump-84758a8c-6502-4c2d-b878-3a97ea0e36a7/</guid><description>起因 近期遭遇 mysqldump 備份 OwnCloud 的 DB 結果 crash 的問題
google 了一下發現 NextCloud 也有人發生類似的問題
Table oc_filecache_extended corrupt?
摘錄連結內的錯誤訊息：
Thread pointer: 0x8548068d8 Attempting backtrace. You can use the following information to find out where mysqld died. If you see no messages after this, something went terribly wrong... stack_bottom = 0x7fffdf76cf38 thread_stack 0x3c000 0x12fcbfc &amp;lt;my_print_stacktrace+0x3c&amp;gt; at /usr/local/libexec/mariadbd 0xc6330f &amp;lt;handle_fatal_signal+0x28f&amp;gt; at /usr/local/libexec/mariadbd 0x8018f7de0 &amp;lt;pthread_sigmask+0x530&amp;gt; at /lib/libthr.so.3 Trying to get some variables. Some pointers may be invalid and cause the dump to abort.</description></item><item><title>在 template literal 中使用函數</title><link>https://krapshsa.github.io/posts/template-literal-bea4efe5-2565-42f7-832f-580089f7807d/</link><pubDate>Tue, 21 Jun 2022 16:18:00 +0800</pubDate><guid>https://krapshsa.github.io/posts/template-literal-bea4efe5-2565-42f7-832f-580089f7807d/</guid><description>起因 在 Code Review 的時候，同事原本是使用多次字串相接
const object1 = { a: &amp;#39;somestring&amp;#39;, b: 42 }; let html = `&amp;lt;ul&amp;gt;`; for (const [key, value] of Object.entries(object1)) { html += `&amp;lt;li&amp;gt;${key}: ${value}&amp;lt;/li&amp;gt;`; } html += `&amp;lt;/ul&amp;gt;`; 後來想要表達出 html 的階層結構，想用使用巢狀的方式使用 template literal
解方 要用 function 來做的話可以使用 IIFE
const object1 = { a: &amp;#39;somestring&amp;#39;, b: 42 }; let html = ` &amp;lt;ul&amp;gt; ${ (function(){ let list = &amp;#39;&amp;#39;; for (const [key, value] of Object.entries(object1)) { list += `&amp;lt;li&amp;gt;${key}: ${value}&amp;lt;/li&amp;gt;`; } return list; })() } &amp;lt;/ul&amp;gt; `; 以我簡化的例子來說，使用 IIFE 看起來變得更複雜了，</description></item></channel></rss>